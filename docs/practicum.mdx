---
title: Дерево (структура данных)
section: Дополнительный контент
---

# Дерево как структура данных

Одна из наиболее широко распространённых структур данных в информатике.

**Дерево** – структура данных, представляющая собой древовидную структуру в виде набора связанных узлов.

**Бинарное дерево** — это конечное множество элементов, которое либо пусто, либо содержит элемент (**корень**), связанный с двумя различными бинарными деревьями, называемыми левым и правым поддеревьями. Каждый элемент бинарного дерева называется узлом. Связи между узлами дерева называются его ветвями.

## Определения

*   **Корневой узел** — самый верхний узел дерева.
*   **Корень** — одна из вершин, по желанию наблюдателя.
*   **Лист** или **терминальный** **узел** — узел, не имеющий дочерних элементов.
*   **Внутренний узел** — любой узел дерева, имеющий потомков, и таким образом, не являющийся листом.

## Устройство дерева

В отличие от обычных деревьев, структура данных дерево растет сверху вниз – ее корень находится на самом верху – так удобнее изображать.

![Набросок устройства дерева](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1653426647/5c78bd0cbe2701ad16f5269c6f21bef8\_p87vvi.png "Устройство дерева")

*   У корневого элемента (на картинке узел со значением 2) есть несколько **дочерних узлов** (7 и 5), каждый из которых в свою очередь сам является корнем **поддерева**. Таких уровней может быть сколько угодно.
*   Элемент, у которого нет дочерних узлов, называется **листом**, или **терминальным узлом** (2, 5, 11, 4). Все остальные узлы (кроме корневого), у которых есть потомки, называются **внутренними**.
*   Каждый узел дерева имеет только одного **родителя**, не больше. Кроме корневого узла, у которого родителей нет вообще.
*   **Высота дерева** – длина самой длинной ветви (количество ребер). У дерева на картинке она равна 3 – ветка от корня **2** до листа **5**. Высоту также можно найти для любого внутреннего узла, например, для узла **6** высота равна 1.

<Callout
  type="note"
  text="В общем случае число дочерних узлов в дереве не ограничено, но нас в основном интересуют деревья, узлы которых имеют не больше двух потомков (левый и правый). Такие деревья называются двоичными (бинарными) и широко используются во многих задачах программирования. Далее мы будем работать именно с двоичными деревьями."
  label="Бинарные деревья"
/>

*Кроме двоичных, широкое практическое применение имеют деревья с четырьмя узлами (*[*дерево квадрантов*](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE\_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D0%BD%D1%82%D0%BE%D0%B2)*). Они используются в разработке игр для организации сетки. Каждый узел в таком дереве представляет одно направление (север-запад, юго-восток и так далее).*

## Основные операции

Деревья – довольно сложные структуры. Для работы с иерархическими данными они должны предоставлять ряд алгоритмов.&#x20;

**Основные операции, которые нам нужны:**

*   Добавление нового узла (**add**);
*   Удаление узла по его значению (**remove**);
*   Поиск узла по значению (**find**);
*   Обход всех элементов (**traverse**).

**При необходимости этот список можно расширить более сложными алгоритмами:**

*   Вставка/удаление поддерева;
*   Вставка/удаление ветви;
*   Вставка элемента в определенную позицию;
*   Поиск наименьшего общего предка для двух узлов.

## Реализация дерева на JavaScript

Мы реализуем дерево, начиная с корневого узла. Каждый узел будет содержать собственное значение, а также ссылки на дочерние элементы (на левый и на правый) и на родителя.

> При этом важно, чтобы не было дубликатов и у каждого узла был только один родитель

```javascript
class BinaryTreeNode {
  constructor(value) {
    this.left = null;
    this.right = null;
    this.value = value;
  }

  get height() {
    let leftHeight = this.left ? this.left.height + 1 : 0;
    let rightHeight = this.right ? this.right.height + 1 : 0;
    return Math.max(leftHeight, rightHeight);
  }
 
  setLeft(node) {
    if (this.left) this.left.parent = null;
    if (node) {
      this.left = node;
      this.left.parent = this;
    }
  }

  setRight(node) {
    if (this.right) this.right.parent = null;
    if (node) {
      this.right = node;
      this.right.parent = this;
    }
  }
}
```

Высота узла (`height`) вычисляется рекурсивно, на основе высоты его дочерних узлов.

### Создание дерева

Реализация очень простая, но с ее помощью мы уже можем построить настоящее двоичное дерево, например, такое как на картинке:

![](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1653433178/trstr\_pe2jam.png "")

> Двоичное дерево

```javascript
let bNode = new BinaryTreeNode('b');
aNode.setLeft(bNode);

let cNode = new BinaryTreeNode('c');
aNode.setRight(cNode);

let dNode = new BinaryTreeNode('d');
bNode.setRight(dNode);

let eNode = new BinaryTreeNode('e');
cNode.setLeft(eNode);

let fNode = new BinaryTreeNode('f');
cNode.setRight(fNode);
```

## Обход дерева

Разберем два самых популярных алгоритма обхода деревьев:

*   поиск в глубину (**d**epth-**f**irst **s**earch);
*   поиск в ширину (**b**readth-**f**irst **s**earch).

### DFS: Поиск в глубину

<Callout
  type="note"
  text=" Идея обхода в глубину заключается в максимально возможном спуске по ветвям дерева вниз."
/>

Алгоритм начинает с корневого узла и последовательно проверяет все исходящие из него ребра. Если ребро ведет в вершину, которая ранее не рассматривалась, то алгоритм рекурсивно запускается уже для нее, а после его выполнения продолжается проверка других ребер. Таким образом последовательно осматривается каждая ветка дерева.

> *Визуализация работы алгоритма поиска в глубину в прямом порядке*

![Визуализация работы алгоритма поиска в глубину.](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1653431581/dfs\_mi1lun.gif "Визуализация работы алгоритма поиска в глубину.")

**Существует три модификации алгоритма с разным способом перебора узлов:**

*   обход в **прямом** порядке, или предупорядоченный обход (pre-order walk). Перебор начинается с родительского узла и идет вниз, к дочерним;
*   обход в **обратном** порядке, или поступорядоченный (post-order walk). Сначала перебираем левого и правого потомков, а потом родителя;
*   **симметричный** обход. Начинаем с левого потомка, потом родитель, потом правый потомок.

### Визуализация модификации обхода дерева в глубину

Три вида обхода бинарного дерева: симметричный (**in-order)**, прямой (**pre-order)** и обратный (**post-order**).&#x20;

<VideoPlayer url="https://storage.googleapis.com/csanims_visualizations/trees/InorderPreorderPostorder.mp4"/>

## BFS: Поиск в ширину

<Callout
  type="note"
  text=" Обход в ширину работает не по веткам, а по уровням дерева."
/>

Алгоритм начинает с корневого узла (первый уровень) и двигается по всем ребрам, выходящим из него, перебирая последовательно каждый дочерний элемент (второй уровень). Когда все ребра проверены, алгоритм переходит на следующий уровень и начинает перебирать дочерние элементы дочерних элементов (элементы третьего уровня) и так далее.&#x20;

> Визуализация работы алгоритма поиска в ширину.

![Визуализация работы алгоритма поиска в ширину.](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1653431969/BFS\_y2xuqh.gif "Визуализация работы алгоритма поиска в ширину.")

## Бинарное дерево поиска

<Callout
  type="note"
  text=" Одно из самых распространенных использований деревьев – упрощение поиска информации. В первой статье цикла мы говорили о том, что данные проще и быстрее искать в отсортированном массиве. Так вот, их также просто искать в упорядоченном дереве, о котором мы сейчас и поговорим."
  label=""
/>

[Двоичное (бинарное) дерево поиска](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5\_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE\_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0) (binary search tree, BST) – это дерево, в котором элементы размещаются согласно определенному правилу (упорядоченно):

*   Каждый узел должен быть "**больше**" любого элемента в своем левом поддереве.
*   Каждый узел должен быть "**меньше**" любого элемента в своем правом поддереве.

*Слова "больше" и "меньше" соответственно означают результат сравнения двух узлов функцией-компаратором.*

> Пример бинарного дерева поиска.

![](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1653432335/bst\_z0jloe.jpg "")

***Благодаря такой сортировке мы можем использовать все преимущества стратегии  – при поиске элемента можно смело отбрасывать половину дерева. Такие алгоритмы работают гораздо быстрее, чем линейный перебор каждого узла.***

### Реализация на JavaScript

Для создания бинарного дерева поиска мы используем уже готовый класс `BinaryTreeNode`, немного его расширив. Необходимо добавить метод `insert`, определяющий логику вставки нового узла для сохранения сортировки. Также создадим отдельный класс для самого дерева, который будет хранить ссылку на корневой элемент и делегировать ему рекурсивное выполнение различных методов.

Так как бинарное дерево поиска является упорядоченным, нам еще потребуется функция-компаратор для сравнения элементов.

```javascript
class BinarySearchTreeNode extends BinaryTreeNode {
  constructor(value, comparator) {
    super(value);
    this.comparator = comparator;
  }

  insert(value) {
    if (this.comparator(value, this.value) < 0) {
      if (this.left) return this.left.insert(value);
      let newNode = new BinarySearchTreeNode(value, this.comparator);
      this.setLeft(newNode);

      return newNode;
    }

    if (this.comparator(value, this.value) > 0) {
      if (this.right) return this.right.insert(value);
      let newNode = new BinarySearchTreeNode(value, this.comparator);
      this.setRight(newNode);

      return newNode;
    }
    return this;
  }
}

class BinarySearchTree {
  constructor(value, comparator) {
    this.root = new BinarySearchTreeNode(value, comparator);
    this.comparator = comparator;
  }

```

\*Метод *insert*, сравнивает значение нового элемента со значением узла и определяет, в какое поддерево его нужно поместить. \*

Создадим дерево:

```
const tree = new BinarySearchTree(8, (a, b) => a - b);
tree.insert(3);
tree.insert(10);
tree.insert(14);
tree.insert(1);
tree.insert(6);
tree.insert(4);
tree.insert(7);
tree.insert(13);
```

А теперь обойдем все его элементы, чтобы убедиться, что оно сформировано правильно:

```
traverseBF(tree.root);
```

&#x20;Вывод в консоль должен быть в таком порядке:

**8** -> **3** -> **10** -> **1** -> **6**-> **14** -> **4**-> **7**-> **13**

### Поиск в бинарном дереве поиска

<Callout
  type="default"
  text="Все эти сложности со вставкой новых узлов и сортировкой дерева нужны для того, чтобы обеспечить удобный поиск по нему."
/>

Алгоритм поиска в BST очень похож на двоичный поиск в отсортированном массиве, который мы разбирали в первой части цикла. Сравниваем искомое значение с корневым узлом, определяем, в каком поддереве нужно искать, а второе поддерево просто отбрасываем.

```javascript
class BinarySearchTree {
  find(value) {
    return this.root.find(value);
  }
}

class BinarySearchTreeNode {
  find(value) {
    if (this.comparator(this.value, value) === 0) return this;

    if (this.comparator(this.value, value) < 0 && this.left) {
      return this.left.find(value);
    }

    if (this.comparator(this.value, value) > 0 && this.right) {
      return this.right.find(value);
    }

    return null;
  }
}
```

> Алгоритм поиска рекурсивно проверяет все узлы, пока не найдет подходящий.

### Эффективность

Временная сложность всех основных операций в бинарном дереве составляет **log(n)** – это эффективная структура данных.

## Двоичная куча | Binary  Heap

<Callout
  type="note"
  text=" Еще одна древоподобная структура, о которой следует знать – это куча."
  label=""
/>

\*У кучи также есть корень, а элементы могут иметь дочерние узлы. У двоичной кучи каждый узел может иметь не более двух потомков. \*

Как и бинарное дерево поиска, куча имеет определенные требования к размещению элементов: все потомки узла должны быть меньше его. Куча,&#x20;
соответствующая этому правилу, называется max-кучей. В ней корень всегда является максимальным элементом.

![](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1653433951/maxheap\_z1trbt.png "")

Бывают также min-кучи, которые следуют противоположному правилу: все потомки узла должны быть больше его. Таким образом, корнем всегда оказывается минимальный элемент кучи.

![](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1653433954/minheap\_vc7anu.png "")

<Callout
  type="note"
  text=" Куча – это самобалансирующаяся структура, при каждой операции она сортирует себя, чтобы все уровни дерева (кроме последнего) были заполнены."
/>

По сути, куча – это **очередь с приоритетом**. Каждый новый элемент размещается в этой очереди в соответствии с его приоритетом, чем приоритет выше, тем ближе он к началу очереди.&#x20;

Каждую кучу можно представить в виде линейного массива:

![](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1653434263/heaparr\_lvjixc.png "")

*Чаще всего используется именно линейная реализация, однако дерево более наглядно демонстрирует принцип распределения*

### &#xA;Основные операции

Базовые операции с кучей такие же, как и с очередью:

*   найти элемент с максимальным приоритетом (максимальный элемент в max-куче или минимальный элемент в min-куче);
*   удалить элемент с максимальным приоритетом;
*   добавить в очередь новый элемент.

[Отличная визуальная репрезентация min-кучи с интерактивом\*](https://www.cs.usfca.edu/~galles/visualization/Heap.html)

## Заключение

Деревья  – довольно сложная (по сравнению с линейными), но очень интересная структура данных. Об одном из самых популярных ее применений (поиске&#x20;
данных) мы уже поговорили.

<Callout
  type="default"
  text="Деревья также широко применяются для управления различными иерархиями (каталоги), принятием решений (игры), а также для парсинга и синтаксического разбора выражений. Различные компиляторы основаны именно на деревьях. Значение деревьев в программирование очень велико, так как они позволяют вырваться из линейных структур и обеспечить более удобный в ряде случаев способ представления данных."
/>

В следующей статье мы пойдем еще дальше и поговорим самой нелинейной структуре – [графах](https://proglib.io/p/rasprostranennye-algoritmy-i-struktury-dannyh-v-javascript-grafy-2021-10-20) – и алгоритмах работы с ней.

# Источники

*   Tree (data structure), ([wikipedia.org](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE\_\(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0\_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85\))), 2022
*   Деревья ([synset.com](https://synset.com/ai/ru/data/Trees.html)), 2017
*   Tree Traversal - inorder, preorder and postorder, ([programiz.com](https://www.programiz.com/dsa/tree-traversal)), 2020
*   The Base 1.5 Representation Tree (visual construction),  ([Micro Visual Proofs](https://www.youtube.com/watch?v=T6su\_\_r-IF8)) 2022
*   Depth First Traversal: Inorder, Preorder and Postorder tree traversals ([csanim.com](https://csanim.com/tutorials/inorder-preorder-and-postorder-tree-traversals-animated-guide)), 2018
*   Tree Traversal (Depth-First and Breadth-First Search), ([leios-labs.com](https://www.youtube.com/watch?v=cZPXfl\_tUkA)), 2017
*   4 ways to Traverse binary trees, ([dev.to](https://dev.to/abdisalan\_js/4-ways-to-traverse-binary-trees-with-animations-5bi5)), 2020
*   Visualizing Graph Traversal, ([xqcl-valentus.com](https://www.kaggle.com/code/kmader/visualizing-graph-traversal/notebook)), 2019
