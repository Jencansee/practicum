---
title: Алгоритмы и программы
section: Разработка приложений
---

# Алгоритмы и программы

Понятие *алгоритма* является одним из основных в современной науке и практике. Еще на самых ранних ступенях развития математики (Древний Египет, Вавилон, Греция) в ней стали рассматриваться различные вычислительные процессы чисто механического характера. С их помощью искомые величины ряда задач вычислялись последовательно из исходных величин по определенным правилам и инструкциям. Со временем все такие процессы в математике получили название алгоритмов (алгорифмов).

Алгоритм есть совокупность четко определенных правил, процедур или команд, обеспечивающих решение поставленной задачи за конечное число шагов.

Термин *алгоритм* происходит от имени средневекового узбекского математика Аль-Хорезми, который еще в IX в. (825 г.) дал правила выполнения четырех арифметических действий в десятичной системе счисления. Процесс выполнения арифметических действий был назван *алгоризмом.*

С 1747 г. вместо слова *алгоризм* стали употреблять *алгорисмус, *смысл которого состоял в комбинировании четырех операций арифметического исчисления — сложения, вычитания, умножения, деления.

К 1950 г. *алгорисмус* стал *алгорифмом.* Смысл алгорифма чаще всего связывался с алгорифмами Евклида — процессами нахождения наибольшего общего делителя двух многочленов, наибольшей общей меры двух отрезков и т. п.

*Способы записи алгоритмов*

Алгоритм должен быть понятен (доступен) пользователю и/или машине. Доступность пользователю означает, что он обязан отображаться посредством конкретных формализованных изобразительных средств, понятных пользователю. В качестве таких изобразительных средств используются следующие способы их записи:

*   словесный;
*   формульный;
*   табличный;
*   операторный;
*   графический;
*   язык программирования.

При словесном способе записи содержание последовательных этапов алгоритма описывается в произвольной форме на естественном языке.

Формульный способ основан на строго формализованном аналитическом задании необходимых для исполнения действий.

Табличный способ подразумевает отображение алгоритма в виде таблиц, использующих аппарат реляционного исчисления и алгебру логики для задания подлежащих исполнению взаимных связей между данными, содержащимися в таблице.

Операторный способ базируется на использовании для отображения алгоритма условного набора специальных операторов: арифметических, логических, печати, ввода данных и т. д.; операторы снабжаются индексами и между ними указываются необходимые переходы, а сами индексированные операторы описываются чаще всего в табличной форме.

Графическое отображение алгоритмов в виде блок-схем — весьма наглядный и распространенный способ. Графические символы, отображающие выполняемые процедуры, стандартизованы. Наряду с основными символами используются и вспомогательные, поясняющие процедуры и связи между ними.

Алгоритмы могут быть записаны и в виде команд какого-либо языка программирования. Если это макрокоманды, то алгоритм читаем и пользователем-программистом, и вычислительной машиной, имеющей транслятор с соответствующего языка.

Приведем пример словесного представления алгоритма на примере нахождения произведения *п* натуральных чисел *(с= п = =* 1 х 2 х 3 х 4 х ... х *п).*
\
Этот процесс может быть записан в виде следующей системы последовательных указаний (пунктов):

1\. Полагаем с равным единице и переходим к следующему пункту.\
2\. Полагаем / равным единице и переходим к следующему пункту.

3\. Полагаем с равным с=сх/ и переходим к следующему указанию.\
4\. Проверяем, равно ли /' числу п. Если / = п, то вычисления прекращаем. Если / \< п, то увеличиваем / на единицу и переходим к пункту 3.\
**

## Классификация и свойства алгоритмов

Алгоритмы, в соответствии с которыми решение поставленных задач сводится к арифметическим действиям, называются численными алгоритмами.

Алгоритмы, в соответствии с которыми решение поставленных задач сводится к логическим действиям, называются логическими алгоритмами. Примерами логических алгоритмов могут служить алгоритмы поиска минимального числа, поиска пути на графе, поиска пути в лабиринте и др.

Алгоритмом является последовательность четких однозначных указаний, которые, будучи применены к определенным имеющимся данным, обеспечивают получение требуемого результата. Данными называют все величины, участвующие в решении задачи. Данные, известные перед выполнением алгоритма, являются начальными, исходными данными. Результат решения задачи — это конечные, выходные данные.

Каждое указание алгоритма предписывает исполнителю выполнить одно конкретное законченное действие. Исполнитель не может перейти к выполнению следующей операции, не закончив полностью выполнения предыдущей. Предписания алгоритма надо выполнять последовательно одно за другим, в соответствии с указанным порядком их записи. Выполнение всех предписаний гарантирует правильное решение задачи.

Поочередное выполнение команд алгоритма за конечное число шагов приводит к решению задачи, к достижению цели. Разделение выполнения решения задачи на отдельные операции (выполняемые исполнителем по определенным командам) — важное свойство алгоритмов, называемое дискретностью.

Для того чтобы алгоритм мог быть выполнен, нельзя включать в него команды, которые исполнитель не в состоянии исполнить. У каждого исполнителя имеется свой перечень команд, которые он может выполнить. Совокупность команд, которые могут быть выполнены исполнителем, называется системой команд исполнителя.

Каждая команда алгоритма должна определять однозначное действие исполнителя. Такое свойство алгоритмов называется определенностью (или точностью) алгоритма.

Алгоритм, составленный для конкретного исполнителя, должен включать только те команды, которые входят в его систему команд. Это свойство алгоритма называется понятностью. Алгоритм не должен быть рассчитан на принятие каких-либо самостоятельных решений исполнителем, не предусмотренных составлением алгоритма.

Еще одно важное требование, предъявляемое к алгоритмам, — результативность (или конечность) алгоритма. Оно означает, что исполнение алгоритма должно закончиться за конечное число шагов.

Поскольку разработка алгоритмов — процесс творческий, требующий умственных усилий и затрат времени, предпочтительно разрабатывать алгоритмы, обеспечивающие решения всего класса задач данного типа. Например, если составляется алгоритм решения кубического уравнения ах3 + Ьх2 + сх + с1 = 0, то он должен быть вариативен, т. е. обеспечивать возможность решения для любых допустимых исходных значений коэффициентов а, Ь, с, с1. Про такой алгоритм говорят, что он удовлетворяет требованию массовости. Свойство массовости не является необходимым свойством алгоритма. Оно, скорее, определяет качество алгоритма; в то же время свойства точности, понятности и конечности являются необходимыми (иначе это не алгоритм).

### Запись алгоритмов в виде блок-схем

Алгоритмы можно записывать по-разному. Форма записи, состав и количество операций алгоритма зависят от того, кто будет исполнителем этого алгоритма. Если задача решается с помощью ЭВМ, алгоритм решения задачи должен быть записан в понятной для машины форме, т. е. в виде программы.

Схема алгоритма — графическое представление алгоритма, дополняемое элементами словесной записи. Каждый пункт алгоритма отображается на схеме некоторой геометрической фигурой или блоком. При этом правило выполнения схем алгоритмов регламентирует ГОСТ 19.002—80 «Единая система программной документации» (табл. 1.28).

Блоки на схемах соединяются линиями потоков информации. Основное направление потока информации идет сверху вниз и слева направо (стрелки могут не указываться), снизу вверх и справа налево — стрелка обязательна. Количество входящих линий для блока не ограничено. Выходящая линия — одна, за исключением логического блока.

![](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1654119540/algo_ireh15.png)

## Базовые структуры алгоритмов

Это определенный набор блоков и стандартных способов их соединения для выполнения типичных последовательных действий. К основным структурам относятся следующие — линейные, разветвляющиеся, циклические (рис. 1.26).

![](https://res.cloudinary.com/dzfsp6wbp/image/upload/v1654119638/814513-88_gzcr06.jpg)


Рис. 1.26. Примеры структур алгоритмов: *а* — линейный алгоритм; *б* — алгоритм с ветвлением; *в* — алгоритм с циклом

**Линейными** называются алгоритмы, в которых действия осуществляются последовательно друг за другом. Стандартная блок-схема линейного алгоритма приводится на рис. 1.26, *а* (вычисление суммы двух чисел — *А* и *В).*

**Разветвляющимся** называется алгоритм, который, в отличие от линейных алгоритмов, содержит условие, в зависимости от истинности или ложности которого выполняется та или иная последовательность команд. Таким образом, команда ветвления состоит из условия и двух последовательностей команд.

Примером может являться разветвляющийся алгоритм, изображенный в виде блок-схемы (рис. 1.26, *б).* Аргументами этого алгоритма являются две переменные *А, В*, а результатом — переменная *X.* Если условие *А > В* истинно, то выполняется операция *X* := *А* х *В,* в противном случае выполняется *X* := *А* + *В.* В результате печатается то значение переменной *X,* которое она получает при выполнении одной из серий команд.

**Циклическим** называется алгоритм, в котором некоторая последовательность операций (тело цикла) выполняется многократно. Однако «многократно» не означает «до бесконечности». Организация циклов, никогда не приводящая к остановке в выполнении алгоритма, является нарушением требования его результативности — получения результата за конечное число шагов.

В цикл в качестве базовых входят — блок проверки условия и тело цикла. Перед операцией цикла осуществляется начальное присвоение значений тем переменным, которые используются в теле цикла. Если тело цикла расположено после проверки условий *Р* (цикл с предусловием), то может случиться так, что при определенных условиях тело цикла не выполнится ни разу. Такой вариант организации цикла, управляемый предусловием, называется *цикл «ПОКА»/«WHILE»* (здесь условие — это условие на продолжение цикла).

Возможен другой случай, когда тело цикла выполняется, по крайней мере, один раз и будет повторяться до тех пор, пока не станет истинным условие. Такая организация цикла, когда его тело расположено перед проверкой условия, носит название цикла с постусловием, или *цикла «ДО»/«FOR».* Истинность условия в этом случае — условие окончания цикла. Отметим, что возможна ситуация с постусловием и при организации цикла «ПОКА». Итак, цикл «ДО» завершается, когда условие становится истинным, а цикл «ПОКА» — когда становился ложным. Современные языки программирования имеют достаточный набор операторов, реализующих как цикл «ПОКА», так и цикл «ДО».

Рассмотрим пример алгоритма вычисления факториала, изображенный на рис. 1.26 (с циклом «ПОКА»). Переменная *N* получает значение числа, факториал которого вычисляется. Переменной *N,* которая в результате выполнения алгоритма должна получить значение факториала, присваивается первоначальное значение 1. Переменной *К* также присваивается значение 1. Цикл будет выполняться, пока справедливо условие *N> К.* Тело цикла состоит из двух операций *N = N1 х К* и *К= К +* 1.\


\
Функции и процедуры на Javascript
---------------------------------

Напишем функцию на языке программирования Javascript, функция будет отображать в консоль сколько раз произошел цикл в зависимости от переданного аргумента.&#x20;

Попробуйте написать такую функцию самостоятельно, используя эту базу:

```
function iterateAmount (num) {	
  // ... ваш код будет здесь
}

iterateAmount(10);
```

В функции используйте любой цикл который вы знаете (for, while, do-while, map).&#x20;

Для вывода комманд в консоль используйте `console.log()`&#x20;

> Если все получилось правильно, то ваш результат в консоли должен выглядить примерно вот так:

```
VM105:4 Итерация произшла №0 раз
VM105:4 Итерация произшла №1 раз
VM105:4 Итерация произшла №2 раз
VM105:4 Итерация произшла №3 раз
VM105:4 Итерация произшла №4 раз
VM105:4 Итерация произшла №5 раз
VM105:4 Итерация произшла №6 раз
VM105:4 Итерация произшла №7 раз
VM105:4 Итерация произшла №8 раз
VM105:4 Итерация произшла №9 раз
```

Готовы? Проверяйте как сделал я:

```
function iterateAmount (num) {
	let amount = 0;
	while(amount < num) {
		console.log(`Итерация произшла №${amount + 1} раз`);
		amount++;
	}
}

iterateAmount(10);
```

## Условия

Давайте улучшим прошлый код так чтобы в консоль выводилось только счетное число.&#x20;

Для получения счетного числа будем использовать оператор или операндом **Модуль числа,** который помечается** %.**

> % - Возвращает значение остатка при делении первого числа на второе. Результат будет иметь тот же знак, что и первое число.

`11 % 3 = 2` (поскольку число 3 вмещается три раза, остатком будет число&#x20;

`10 % 2 = 0` - остатка не будет

Теперь давайте улучшим код:

```
function iterateAmount (num) {
	let amount = 0;
	while(amount < num) {
		if (amount % 2) {
			console.log(`Итерация произшла №${amount + 1} раз`);
		}
 
		amount++;
	}
}
```

Вывод будет следующий:

```
VM110:5 Итерация произшла №2 раз
VM110:5 Итерация произшла №4 раз
VM110:5 Итерация произшла №6 раз
VM110:5 Итерация произшла №8 раз
VM110:5 Итерация произшла №10 раз
```

Заметьте, что мы используем условие if - если текущее число делится на два без остатка, то тогда выдаем значение, в ином случае мы ничего не делаем.

Но, строчка `amount++;` будет исполняться в любом случае, т.к не находится в теле условия, поэтому интерпретатор Javascript языка будет пропускать условие **if** и увеличивать текущую переменную `amount`

Давайте, слегка улучшим этот код еще чтобы если число делится с остатком писалось бы: 'Интерация произошла №n, число с остатком.'

```
...
	while(amount < num) {
		if (amount % 2) {
			console.log(`Итерация произшла №${amount + 1} раз`);
		}
        else {    
          console.log(`Интерация произошла №${amount + 1}, число с остатком.`)
        }
 
		amount++;
...
```

Мы использовали условие **else **что значит если не одно из условий внутри тела не подходит, то будет использоваться **else **- если оно пресутствует.

Также есть конструкция **else if **- она используется бесконечное количество раз, между  **if** и заключительным **else**
